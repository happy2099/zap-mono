/**
 * DeBridge Analyzer - Enhanced DEX Analysis using DeBridge Finance Parser
 * Supports: Raydium (launchpad, AMM, v4, CPMM, CLMM) and Meteora (DBC, DLMM, CPAMM)
 */

const { SolanaParser } = require('@debridge-finance/solana-transaction-parser');
const { PublicKey } = require('@solana/web3.js');
const config = require('./config.js');

class DeBridgeAnalyzer {
    constructor() {
        // Initialize DeBridge parser with empty programInfos array
        this.parser = new SolanaParser([], []);
        // Raydium programs from config.js
        this.raydiumPrograms = new Set([
            config.PLATFORM_IDS.RAYDIUM_V4.toBase58(),           // Raydium v4
            config.PLATFORM_IDS.RAYDIUM_LAUNCHPAD.toBase58(),    // Raydium Launchpad
            config.PLATFORM_IDS.RAYDIUM_CPMM.toBase58(),         // Raydium CPMM
            config.PLATFORM_IDS.RAYDIUM_CLMM.toBase58(),         // Raydium CLMM
            config.PLATFORM_IDS.RAYDIUM_AMM.toBase58(),          // Raydium AMM
            config.PLATFORM_IDS.RAYDIUM_STABLE_SWAP.toBase58()  // Raydium Stable Swap
        ]);
        
        // Meteora programs from config.js
        this.meteoraPrograms = new Set([
            config.PLATFORM_IDS.METEORA_DLMM.toBase58(),         // Meteora DLMM
            config.PLATFORM_IDS.METEORA_CP_AMM.toBase58()        // Meteora CP AMM
        ]);
        
        // Add Meteora DBC programs (array of program IDs)
        config.PLATFORM_IDS.METEORA_DBC.forEach(programId => {
            this.meteoraPrograms.add(programId.toBase58());
        });
    }

    /**
     * Check if a program ID is a Raydium program
     */
    isRaydiumProgram(programId) {
        return this.raydiumPrograms.has(programId);
    }

    /**
     * Check if a program ID is a Meteora program
     */
    isMeteoraProgram(programId) {
        return this.meteoraPrograms.has(programId);
    }

    /**
     * Check if a program ID is supported by DeBridge
     */
    isSupportedProgram(programId) {
        return this.isRaydiumProgram(programId) || this.isMeteoraProgram(programId);
    }

    /**
     * Analyze transaction using DeBridge parser
     */
    async analyzeTransaction(transaction) {
        try {
            console.log('[DEBRIDGE-ANALYZER] 🔍 Analyzing transaction with DeBridge parser...');
            
            // Parse transaction using DeBridge
            const parsedTx = await this.parser.parseTransaction(transaction);
            
            if (!parsedTx || !parsedTx.instructions) {
                console.log('[DEBRIDGE-ANALYZER] ❌ No instructions found in parsed transaction');
                return null;
            }

            // Find the core swap instruction
            const coreInstruction = this.findCoreSwapInstruction(parsedTx.instructions);
            
            if (!coreInstruction) {
                console.log('[DEBRIDGE-ANALYZER] ❌ No core swap instruction found');
                return null;
            }

            // Extract trade details
            const tradeDetails = this.extractTradeDetails(coreInstruction, parsedTx);
            
            console.log('[DEBRIDGE-ANALYZER] ✅ Successfully analyzed transaction');
            return {
                success: true,
                cloningTarget: coreInstruction,
                tradeDetails: tradeDetails,
                platform: this.getPlatform(coreInstruction.programId),
                analysisType: 'debridge'
            };

        } catch (error) {
            console.log('[DEBRIDGE-ANALYZER] ❌ Analysis failed:', error.message);
            return null;
        }
    }

    /**
     * Find the core swap instruction from parsed instructions
     */
    findCoreSwapInstruction(instructions) {
        for (const instruction of instructions) {
            if (this.isSwapInstruction(instruction)) {
                console.log('[DEBRIDGE-ANALYZER] 🎯 Found core swap instruction:', instruction.name);
                return instruction;
            }
        }
        return null;
    }

    /**
     * Check if instruction is a swap instruction
     */
    isSwapInstruction(instruction) {
        const swapNames = [
            'swap', 'swapBaseIn', 'swapBaseOut', 'swapExactIn', 'swapExactOut',
            'swapExactInForExactOut', 'swapExactOutForExactIn', 'swapV2',
            'swapExactInForExactOutV2', 'swapExactOutForExactInV2'
        ];
        
        return swapNames.some(name => 
            instruction.name && instruction.name.toLowerCase().includes(name.toLowerCase())
        );
    }

    /**
     * Extract trade details from core instruction
     */
    extractTradeDetails(coreInstruction, parsedTx) {
        const tradeDetails = {
            programId: coreInstruction.programId,
            instructionName: coreInstruction.name,
            accounts: coreInstruction.accounts || [],
            data: coreInstruction.data,
            platform: this.getPlatform(coreInstruction.programId)
        };

        // Extract specific details based on platform
        if (this.isRaydiumProgram(coreInstruction.programId)) {
            tradeDetails.raydiumDetails = this.extractRaydiumDetails(coreInstruction);
        } else if (this.isMeteoraProgram(coreInstruction.programId)) {
            tradeDetails.meteoraDetails = this.extractMeteoraDetails(coreInstruction);
        }

        return tradeDetails;
    }

    /**
     * Extract Raydium-specific details
     */
    extractRaydiumDetails(instruction) {
        return {
            type: this.getRaydiumType(instruction.programId),
            instructionName: instruction.name,
            accounts: instruction.accounts?.map(acc => ({
                pubkey: acc.pubkey,
                isSigner: acc.isSigner,
                isWritable: acc.isWritable
            })) || []
        };
    }

    /**
     * Extract Meteora-specific details
     */
    extractMeteoraDetails(instruction) {
        return {
            type: this.getMeteoraType(instruction.programId),
            instructionName: instruction.name,
            accounts: instruction.accounts?.map(acc => ({
                pubkey: acc.pubkey,
                isSigner: acc.isSigner,
                isWritable: acc.isWritable
            })) || []
        };
    }

    /**
     * Get Raydium type based on program ID
     */
    getRaydiumType(programId) {
        const typeMap = {
            [config.PLATFORM_IDS.RAYDIUM_V4.toBase58()]: 'v4',
            [config.PLATFORM_IDS.RAYDIUM_LAUNCHPAD.toBase58()]: 'Launchpad',
            [config.PLATFORM_IDS.RAYDIUM_CPMM.toBase58()]: 'CPMM',
            [config.PLATFORM_IDS.RAYDIUM_CLMM.toBase58()]: 'CLMM',
            [config.PLATFORM_IDS.RAYDIUM_AMM.toBase58()]: 'AMM',
            [config.PLATFORM_IDS.RAYDIUM_STABLE_SWAP.toBase58()]: 'StableSwap'
        };
        return typeMap[programId] || 'Unknown';
    }

    /**
     * Get Meteora type based on program ID
     */
    getMeteoraType(programId) {
        const typeMap = {
            [config.PLATFORM_IDS.METEORA_DLMM.toBase58()]: 'DLMM',
            [config.PLATFORM_IDS.METEORA_CP_AMM.toBase58()]: 'CPAMM'
        };
        
        // Add DBC programs
        config.PLATFORM_IDS.METEORA_DBC.forEach(programId => {
            typeMap[programId.toBase58()] = 'DBC';
        });
        
        return typeMap[programId] || 'Unknown';
    }

    /**
     * Get platform name
     */
    getPlatform(programId) {
        if (this.isRaydiumProgram(programId)) {
            return 'Raydium';
        } else if (this.isMeteoraProgram(programId)) {
            return 'Meteora';
        }
        return 'Unknown';
    }

    /**
     * Get cloning strategy for specific platform
     */
    getCloningStrategy(programId) {
        if (this.isRaydiumProgram(programId)) {
            return this.getRaydiumCloningStrategy(programId);
        } else if (this.isMeteoraProgram(programId)) {
            return this.getMeteoraCloningStrategy(programId);
        }
        return null;
    }

    /**
     * Get Raydium cloning strategy
     */
    getRaydiumCloningStrategy(programId) {
        const strategies = {
            [config.PLATFORM_IDS.RAYDIUM_V4.toBase58()]: { // v4
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            },
            [config.PLATFORM_IDS.RAYDIUM_CPMM.toBase58()]: { // CPMM
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            },
            [config.PLATFORM_IDS.RAYDIUM_CLMM.toBase58()]: { // CLMM
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            },
            [config.PLATFORM_IDS.RAYDIUM_AMM.toBase58()]: { // AMM
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            }
        };
        return strategies[programId] || strategies[config.PLATFORM_IDS.RAYDIUM_V4.toBase58()];
    }

    /**
     * Get Meteora cloning strategy
     */
    getMeteoraCloningStrategy(programId) {
        const strategies = {
            [config.PLATFORM_IDS.METEORA_DLMM.toBase58()]: { // DLMM
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            },
            [config.PLATFORM_IDS.METEORA_CP_AMM.toBase58()]: { // CPAMM
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            }
        };
        
        // Add DBC strategies
        config.PLATFORM_IDS.METEORA_DBC.forEach(programId => {
            strategies[programId.toBase58()] = {
                accountMapping: {
                    'user': 'user',
                    'userTokenAccount': 'userTokenAccount',
                    'userTokenAccountB': 'userTokenAccountB'
                },
                surgicalTargets: ['amountIn', 'amountOut']
            };
        });
        
        return strategies[programId] || strategies[config.PLATFORM_IDS.METEORA_DLMM.toBase58()];
    }
}

module.exports = { DeBridgeAnalyzer };
