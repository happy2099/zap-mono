// ==========================================
// ========== Trade Executor Worker ==========
// ==========================================
// File: workers/tradeExecutorWorker.js
// Description: Executes trades in a separate thread

const { workerData, parentPort } = require('worker_threads');
const BaseWorker = require('./templates/baseWorker');
const { DataManager } = require('../dataManager');
const { SolanaManager } = require('../solanaManager');
const { SingaporeSenderManager } = require('../singaporeSenderManager');
const WalletManager = require('../walletManager');
// TransactionAnalyzer removed - using UniversalAnalyzer instead
const { ApiManager } = require('../apiManager');
const TradeNotificationManager = require('../tradeNotifications');
const config = require('../config');

// Direct transaction building imports
const { PublicKey } = require('@solana/web3.js');
const { 
    getAssociatedTokenAddressSync, 
    createAssociatedTokenAccountInstruction,
    TOKEN_PROGRAM_ID 
} = require('@solana/spl-token');

// Borsh serialization for instruction data
const borsh = require('borsh');
const BN = require('bn.js');
const { createHash } = require('crypto');

// Worker Manager Interface for communicating with main thread
class WorkerManagerInterface {
    constructor() {
        this.parentPort = parentPort;
    }

    dispatch(workerType, message) {
        if (this.parentPort) {
            this.parentPort.postMessage({
                type: 'SEND_NOTIFICATION',
                workerName: 'executor',
                payload: message.payload
            });
        }
    }
}

class TradeExecutorWorker extends BaseWorker {
    constructor() {
        super();
        this.dataManager = null;
        this.solanaManager = null;
        this.singaporeSender = null; // NEW: Ultra-fast Helius Sender
        this.walletManager = null;
        // TransactionAnalyzer removed
        this.apiManager = null;
        this.redisManager = null;
        this.notificationManager = null;
        this.tradingEngine = null;
        this.pendingTrades = new Map();
        this.completedTrades = new Map();
        this.failedTrades = new Map();
        this.workerManager = new WorkerManagerInterface();
    }

    setupMessageHandlers() {
        // Call parent setup first
        super.setupMessageHandlers();
        
        // Register executor-specific handlers
        this.registerHandler('HANDLE_SMART_COPY', this.handleSmartCopy.bind(this));
        this.registerHandler('EXECUTE_COPY_TRADE', this.executeCopyTrade.bind(this));
        this.registerHandler('CANCEL_TRADE', this.cancelTrade.bind(this));
        this.registerHandler('GET_TRADE_STATUS', this.getTradeStatus.bind(this));
        this.registerHandler('GET_PENDING_TRADES', this.getPendingTrades.bind(this));
    }

    async customInitialize() {
        try {
            // Initialize core managers
            this.dataManager = new DataManager();
            await this.dataManager.initialize();
            
            this.solanaManager = new SolanaManager();
            await this.solanaManager.initialize();
            
            // NEW: Initialize Ultra-Fast Helius Sender with shared connection
            this.singaporeSender = new SingaporeSenderManager(this.solanaManager.connection);
            this.logInfo('üöÄ Ultra-Fast Helius Sender initialized for sub-200ms execution');
            
            this.walletManager = new WalletManager(this.dataManager);
            this.walletManager.setSolanaManager(this.solanaManager);
            this.walletManager.setConnection(this.solanaManager.connection);
            await this.walletManager.initialize();
            
            this.apiManager = new ApiManager(this.solanaManager);
            // TransactionAnalyzer removed - using UniversalAnalyzer instead
   
            // Replace CacheManager with RedisManager
            const { RedisManager } = require('../redis/redisManager');
            this.redisManager = new RedisManager();
            await this.redisManager.initialize();
            
            // Initialize notification manager with worker manager for threaded communication
            this.notificationManager = new TradeNotificationManager(null, this.apiManager, this.workerManager);
            this.notificationManager.setConnection(this.solanaManager.connection);

            // SIMPLE COPY BOT - No trading engine needed
            this.logInfo('‚úÖ Simple Copy Bot - No trading engine required');

            this.logInfo('Trade executor worker initialized successfully');
        } catch (error) {
            this.logError('Failed to initialize trade executor worker', { error: error.message });
            throw error;
        }
    }

    // Handle smart copy messages from monitor worker
    async handleSmartCopy(message) {
        try {
            this.logInfo('[SMART-COPY-HANDLER] üîß Handling smart copy from monitor worker');
            this.logInfo(`[SMART-COPY-HANDLER] üîç Trader: ${message.traderName || 'Unknown'} (${message.traderWallet})`);
            this.logInfo(`[SMART-COPY-HANDLER] üîç Signature: ${message.signature} (type: ${typeof message.signature})`);
            this.logInfo(`[SMART-COPY-HANDLER] üîç Signature length: ${message.signature ? message.signature.length : 'undefined'}`);
            this.logInfo(`[SMART-COPY-HANDLER] üîç Message keys: ${Object.keys(message)}`);
            this.logInfo(`[SMART-COPY-HANDLER] üîç Analysis result: ${message.analysisResult ? 'Present' : 'Missing'}`);
            
            // Route to main execution function
            await this.executeCopyTrade(message); 

        } catch (error) {
            this.logError(`[SMART-COPY-HANDLER] ‚ùå Error handling smart copy: ${error.message}`);
        }
    }

    // ===== SINGLE EXECUTION FUNCTION =====
    // HANDLES BOTH: EXECUTE_COPY_TRADE AND HANDLE_SMART_COPY
    async executeCopyTrade(message) {
        try {
            this.logInfo('[SINGLE-EXECUTOR] üöÄ Processing copy trade', { 
                type: message.type,
                hasAnalysisResult: !!message.analysisResult,
                hasOriginalTransaction: !!message.originalTransaction
            });

            // Check if we have analysis result
            if (!message.analysisResult) {
                this.logError('[SINGLE-EXECUTOR] ‚ùå No analysis result from monitor - aborting execution');
                return;
            }

            const analysisResult = message.analysisResult;
            let swapDetails = analysisResult.swapDetails;
            
            // ========================= THE SMART ROUTER FIX =========================
            // STEP 1: Perform DEEP analysis inside the executor to determine the TRUE platform.
            // This makes the executor self-reliant and corrects any bad data from the monitor.
            this.logInfo(`[SMART-ROUTER] üïµÔ∏è‚Äç‚ôÇÔ∏è Performing deep analysis to find the REAL DEX...`);
            const realPlatform = this._detectTargetDexFromTransaction(message); // Pass the ENTIRE message
            this.logInfo(`[SMART-ROUTER] ‚úÖ Real target DEX identified: ${realPlatform}`);
            
            // Override the platform in swapDetails to ensure we use the correct one.
            swapDetails.platform = realPlatform;
            // =========================================================
            
            this.logInfo('[SINGLE-EXECUTOR] üéØ Copy trade details', {
                platform: swapDetails.platform,
                inputMint: swapDetails.inputMint,
                outputMint: swapDetails.outputMint,
                inputAmount: swapDetails.inputAmount,
                requiresATACreation: swapDetails.requiresATACreation,
                requiresPDARecovery: swapDetails.requiresPDARecovery
            });

            // Execute PDA/ATA reconstruction if needed
            if (swapDetails.requiresATACreation || swapDetails.requiresPDARecovery) {
                this.logInfo(`[SINGLE-EXECUTOR] üîß Starting PDA/ATA reconstruction...`);
                await this._reconstructPDAAndATA(analysisResult, swapDetails);
                this.logInfo(`[SINGLE-EXECUTOR] ‚úÖ PDA/ATA reconstruction completed`);
            }

            // Get user config from message or use defaults
            const userConfig = message.userConfig || {
                scaleFactor: 0.1,
                slippage: 0.05,
                platformPreferences: ['PumpFun', 'Raydium', 'Jupiter']
            };
            
            this.logInfo(`[SINGLE-EXECUTOR] üîß User config loaded:`, userConfig);
            
            // Route to platform-specific execution
            this.logInfo(`[SINGLE-EXECUTOR] üéØ Routing to platform: ${swapDetails.platform}`);
            
            let result;
            
            // üöÄ NEW: Try DIRECT transaction building first (bypasses API routes)
            // NOTE: LaserStream provides non-standard transaction format, so we skip direct copy for now
            if (false && message.originalTransaction && message.programIds) {
                this.logInfo(`[DIRECT-BUILDER] üîß Attempting DIRECT transaction building from original...`);
                try {
                    result = await this.executeDirectCopyTrade(message, userConfig);
                    this.logInfo(`[DIRECT-BUILDER] ‚úÖ Direct copy successful!`);
                    return result;
                } catch (directError) {
                    this.logWarn(`[DIRECT-BUILDER] ‚ö†Ô∏è Direct copy failed: ${directError.message}, falling back to platform-specific...`);
                }
            }
            
            switch (swapDetails.platform) {
                case 'Jupiter':
                    result = await this.executeJupiterSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
                    break;
                case 'PumpFun':
                    result = await this.executePumpFunSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
                    break;
                case 'Raydium':
                    result = await this.executeRaydiumSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
                    break;
                case 'Orca':
                    result = await this.executeOrcaSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
                    break;
                case 'Meteora':
                    result = await this.executeMeteoraSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
                    break;
                case 'OpenBook':
                    result = await this.executeOpenBookSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
                    break;
                default:
                    this.logWarn(`[SINGLE-EXECUTOR] ‚ö†Ô∏è Unknown platform: ${swapDetails.platform}, defaulting to Jupiter`);
                    result = await this.executeJupiterSwap(swapDetails.inputMint, swapDetails.outputMint, swapDetails.inputAmount, userConfig);
            }

            this.logInfo(`[SINGLE-EXECUTOR] ‚úÖ Copy trade executed successfully!`, {
                platform: swapDetails.platform,
                signature: result?.signature,
                executionTime: result?.executionTime
            });

            return result;

        } catch (error) {
            this.logError('[SINGLE-EXECUTOR] ‚ùå Copy trade execution failed', { error: error.message });
            throw error;
        }
    }
    
    // REMOVED: handleCopyTrade() - REDUNDANT (now integrated into executeCopyTrade)


    async cancelTrade(tradeId) {
        try {
            if (this.pendingTrades.has(tradeId)) {
                const trade = this.pendingTrades.get(tradeId);
                trade.status = 'cancelled';
                
                this.pendingTrades.delete(tradeId);
                this.failedTrades.set(tradeId, {
                    ...trade,
                    endTime: Date.now(),
                    status: 'cancelled'
                });

                this.logInfo('Trade cancelled', { tradeId });
                this.signalMessage('TRADE_CANCELLED', { tradeId });
            } else {
                this.logWarn('Trade not found for cancellation', { tradeId });
            }
        } catch (error) {
            this.logError('Failed to cancel trade', { tradeId, error: error.message });
        }
    }

    async getTradeStatus(tradeId) {
        try {
            let trade = null;
            let status = 'not_found';

            if (this.pendingTrades.has(tradeId)) {
                trade = this.pendingTrades.get(tradeId);
                status = 'pending';
            } else if (this.completedTrades.has(tradeId)) {
                trade = this.completedTrades.get(tradeId);
                status = 'completed';
            } else if (this.failedTrades.has(tradeId)) {
                trade = this.failedTrades.get(tradeId);
                status = 'failed';
            }

            this.signalMessage('TRADE_STATUS_RESPONSE', {
                tradeId,
                status,
                trade
            });
        } catch (error) {
            this.logError('Failed to get trade status', { tradeId, error: error.message });
        }
    }

    async getPendingTrades() {
        try {
            const pendingTrades = Array.from(this.pendingTrades.values());
            this.signalMessage('PENDING_TRADES_RESPONSE', {
                count: pendingTrades.length,
                trades: pendingTrades
            });
        } catch (error) {
            this.logError('Failed to get pending trades', { error: error.message });
        }
    }

    // REMOVED: processTraderActivity() - OBSOLETE (used removed tradingEngine)

    async customCleanup() {
        try {
            // Cancel all pending trades
            const pendingTradeIds = Array.from(this.pendingTrades.keys());
            for (const tradeId of pendingTradeIds) {
                await this.cancelTrade(tradeId);
            }

            // Close database connection
            if (this.dataManager) {
                await this.dataManager.close();
            }

            this.logInfo('Trade executor worker cleanup completed');
        } catch (error) {
            this.logError('Error during cleanup', { error: error.message });
        }
    }

    // ===== PDA/ATA RECONSTRUCTION =====
    
    async _reconstructPDAAndATA(analysisResult, swapDetails) {
        try {
            this.logInfo(`[PDA-ATA] üîß Starting PDA/ATA reconstruction...`);
            
            // Get user's wallet
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            // Get user configs for scale factor and slippage
            const userConfig = analysisResult.userConfig || {
                scaleFactor: 0.1,
                slippage: 0.05,
                platformPreferences: ['PumpFun', 'Raydium', 'Jupiter']
            };
            
            this.logInfo(`[PDA-ATA] üîß User configs:`, {
                scaleFactor: userConfig.scaleFactor,
                slippage: userConfig.slippage,
                platformPreferences: userConfig.platformPreferences
            });
            
            // 1. ATA RECONSTRUCTION: Create Associated Token Accounts if needed
            if (swapDetails.requiresATACreation) {
                this.logInfo(`[PDA-ATA] üîß Creating ATA for ${swapDetails.outputMint}`);
                
                // Check if ATA exists - Pass userWallet.publicKey, NOT the whole userWallet object
                const ataExists = await this._checkATAExists(userWallet.publicKey, swapDetails.outputMint);
                if (!ataExists) {
                    this.logInfo(`[PDA-ATA] üîß ATA does not exist, creating...`);
                    await this._createATA(userWallet, swapDetails.outputMint);
                    this.logInfo(`[PDA-ATA] ‚úÖ ATA created successfully`);
                } else {
                    this.logInfo(`[PDA-ATA] ‚úÖ ATA already exists`);
                }
            }
            
            // 2. PDA RECONSTRUCTION: Reconstruct Program Derived Addresses if needed
            if (swapDetails.requiresPDARecovery) {
                this.logInfo(`[PDA-ATA] üîß Reconstructing PDA for ${swapDetails.platform}`);
                
                // For PumpFun: Reconstruct bonding curve PDA
                if (swapDetails.platform === 'PumpFun') {
                    const bondingCurvePDA = await this._reconstructPumpFunBondingCurve(swapDetails.outputMint);
                    this.logInfo(`[PDA-ATA] ‚úÖ PumpFun bonding curve PDA: ${bondingCurvePDA}`);
                }
                
                // For Raydium: Reconstruct pool PDA
                if (swapDetails.platform === 'Raydium') {
                    const poolPDA = await this._reconstructRaydiumPool(swapDetails.inputMint, swapDetails.outputMint);
                    this.logInfo(`[PDA-ATA] ‚úÖ Raydium pool PDA: ${poolPDA}`);
                }
            }
            
            // 3. APPLY USER CONFIGS: Scale factor and slippage
            const scaledAmount = Math.floor(swapDetails.inputAmount * userConfig.scaleFactor);
            this.logInfo(`[PDA-ATA] üîß Applied user scale factor: ${swapDetails.inputAmount} ‚Üí ${scaledAmount} (${userConfig.scaleFactor * 100}%)`);
            
            // Update swap details with user configs
            swapDetails.scaledAmount = scaledAmount;
            swapDetails.userSlippage = userConfig.slippage;
            
            this.logInfo(`[PDA-ATA] ‚úÖ PDA/ATA reconstruction completed with user configs`);
            
        } catch (error) {
            this.logError(`[PDA-ATA] ‚ùå PDA/ATA reconstruction failed: ${error.message}`);
            throw error;
        }
    }
    
    async _getUserWallet() {
        try {
            // Get the first available user from the database
            const users = await this.dataManager.readJsonFile('users.json');
            if (!users || !users.users) {
                throw new Error('No users found in database');
            }
            
            // Get the first user (admin user)
            const firstUserId = Object.keys(users.users)[0];
            if (!firstUserId) {
                throw new Error('No users found');
            }
            
            const user = users.users[firstUserId];
            this.logInfo(`[PDA-ATA] üîç Using user: ${user.first_name} (${user.chat_id})`);
            
            // Get user's wallet from wallet manager
            if (this.walletManager) {
                const userWallet = await this.walletManager.getPrimaryTradingKeypair(user.chat_id);
                if (userWallet && userWallet.wallet && userWallet.wallet.publicKey) {
                    this.logInfo(`[PDA-ATA] ‚úÖ Found wallet: ${userWallet.wallet.publicKey.toString()}`);
                    return userWallet.wallet; // Return the full wallet object, not just the public key string
                }
            }
            
            // Fallback: use environment variable or config
            const walletFromEnv = process.env.WALLET_PUBLIC_KEY;
            if (walletFromEnv) {
                this.logInfo(`[PDA-ATA] ‚úÖ Using wallet from environment: ${walletFromEnv}`);
                // Convert string to PublicKey object for consistency
                const { PublicKey } = require('@solana/web3.js');
                return { publicKey: new PublicKey(walletFromEnv) };
            }
            
            throw new Error('No user wallet found');
        } catch (error) {
            this.logError(`[PDA-ATA] ‚ùå Failed to get user wallet: ${error.message}`);
            throw error;
        }
    }
    
    async _checkATAExists(owner, mint) {
        try {
            const { PublicKey } = require('@solana/web3.js');
            const { getAssociatedTokenAddress } = require('@solana/spl-token');
            
            // Get ATA address - Handle both PublicKey and Keypair objects
            const ownerPublicKey = owner.publicKey ? owner.publicKey : owner;
            const ataAddress = await getAssociatedTokenAddress(
                new PublicKey(mint),
                new PublicKey(ownerPublicKey)
            );
            
            // Check if account exists using HELIUS RPC (FASTER!)
            const connection = this.solanaManager?.connection;
            if (!connection) {
                throw new Error('Helius RPC connection not available');
            }
            
            this.logInfo(`[PDA-ATA] üîß Checking ATA existence via Helius RPC...`);
            const accountInfo = await connection.getAccountInfo(ataAddress);
            const exists = accountInfo !== null;
            this.logInfo(`[PDA-ATA] üîß ATA exists: ${exists} (checked via Helius RPC)`);
            return exists;
            
        } catch (error) {
            this.logError(`[PDA-ATA] ‚ùå Failed to check ATA existence: ${error.message}`);
            return false;
        }
    }
    
    async _createATA(ownerWallet, mint) {
        try {
            const { PublicKey, Transaction } = require('@solana/web3.js');
            const { createAssociatedTokenAccountInstruction } = require('@solana/spl-token');
            
            const connection = this.solanaManager?.connection;
            if (!connection) {
                throw new Error('Helius RPC connection not available');
            }
            
            // Get ATA address using sync version (faster) - Use ownerWallet.publicKey
            const { getAssociatedTokenAddressSync } = require('@solana/spl-token');
            const ataAddress = getAssociatedTokenAddressSync(
                new PublicKey(mint),
                ownerWallet.publicKey // Use .publicKey here
            );
            
            // Create instruction - Use ownerWallet.publicKey for all PublicKey constructors
            const createATAInstruction = createAssociatedTokenAccountInstruction(
                ownerWallet.publicKey, // payer
                ataAddress, // associated token account
                ownerWallet.publicKey, // owner
                new PublicKey(mint) // mint
            );
            
            // Create transaction
            const transaction = new Transaction().add(createATAInstruction);
            
            // Get recent blockhash via HELIUS RPC (FASTER!)
            this.logInfo(`[PDA-ATA] üîß Getting recent blockhash via Helius RPC...`);
            const { blockhash } = await connection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = ownerWallet.publicKey;
            
            this.logInfo(`[PDA-ATA] üîß ATA transaction created for mint: ${mint}`);
            this.logInfo(`[PDA-ATA] üîß ATA address: ${ataAddress.toString()}`);
            this.logInfo(`[PDA-ATA] üîß Blockhash: ${blockhash} (via Helius RPC)`);
            
            // Note: Transaction needs to be signed and sent by the user's wallet
            // This is just the preparation step
            
        } catch (error) {
            this.logError(`[PDA-ATA] ‚ùå Failed to create ATA: ${error.message}`);
            throw error;
        }
    }
    
    async _reconstructPumpFunBondingCurve(tokenMint) {
        try {
            const { PublicKey } = require('@solana/web3.js');
            
            const pumpFunProgramId = config.PLATFORM_IDS.PUMP_FUN;
            const tokenMintPubkey = new PublicKey(tokenMint);
            
            // Find PDA for PumpFun bonding curve
            const [bondingCurvePDA, bump] = PublicKey.findProgramAddressSync(
                [Buffer.from('bonding-curve'), tokenMintPubkey.toBuffer()],
                pumpFunProgramId
            );
            
            this.logInfo(`[PDA-ATA] üîß PumpFun bonding curve PDA: ${bondingCurvePDA.toString()}`);
            this.logInfo(`[PDA-ATA] üîß Bump: ${bump}`);
            
            return bondingCurvePDA.toString();
            
        } catch (error) {
            this.logError(`[PDA-ATA] ‚ùå Failed to reconstruct PumpFun bonding curve: ${error.message}`);
            throw error;
        }
    }
    
    async _reconstructRaydiumPool(mintA, mintB) {
        try {
            const { PublicKey } = require('@solana/web3.js');
            
            const raydiumProgramId = config.PLATFORM_IDS.RAYDIUM_V4;
            const mintAPubkey = new PublicKey(mintA);
            const mintBPubkey = new PublicKey(mintB);
            
            // Find PDA for Raydium pool
            const [poolPDA, bump] = PublicKey.findProgramAddressSync(
                [Buffer.from('pool'), mintAPubkey.toBuffer(), mintBPubkey.toBuffer()],
                raydiumProgramId
            );
            
            this.logInfo(`[PDA-ATA] üîß Raydium pool PDA: ${poolPDA.toString()}`);
            this.logInfo(`[PDA-ATA] üîß Bump: ${bump}`);
            
            return poolPDA.toString();
            
        } catch (error) {
            this.logError(`[PDA-ATA] ‚ùå Failed to reconstruct Raydium pool: ${error.message}`);
            throw error;
        }
    }

    // ===== SMART ROUTER DETECTION =====
    
    _detectTargetDexFromTransaction(message) {
        try {
            this.logInfo(`[SMART-ROUTER] üîç Analyzing transaction for real DEX...`);
            this.logInfo(`[SMART-ROUTER] üîç Message structure:`, {
                hasAnalysisResult: !!message?.analysisResult,
                hasOriginalTransaction: !!message?.originalTransaction,
                hasLogMessages: !!message?.originalTransaction?.meta?.logMessages
            });
            
            // PRIORITY CHECK: If monitor already detected PumpFun, use it immediately
            if (message?.analysisResult?.swapDetails?.platform === 'PumpFun') {
                this.logInfo(`[SMART-ROUTER] ‚úÖ Monitor detected PumpFun, using directly`);
                return 'PumpFun';
            }
            
            // ========================= THE MAILBOX FIX =========================
            // Look for log messages in the CORRECT path: message.originalTransaction.meta.logMessages
            const logMessages = message?.originalTransaction?.meta?.logMessages;
            
            if (logMessages && Array.isArray(logMessages)) {
                // Join all logs into one big string for easy searching
                const logs = logMessages.join(' ');
                this.logInfo(`[SMART-ROUTER] üîç Log messages (first 200 chars): ${logs.substring(0, 200)}...`);
                
                // This is the "ground truth" check for PumpFun
                if (logs.includes('pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA') || // PumpFun AMM
                    logs.includes('6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P') || // PumpFun Main
                    logs.includes('F5tfvbLog9VdGUPqBDTT8rgXvTTcq7e5UiGnupL1zvBq') || // PumpFun Router
                    logs.includes('pump.fun')) {
                    this.logInfo(`[SMART-ROUTER] ‚úÖ Found PumpFun in log messages`);
                    return 'PumpFun';
                }
                
                // Check for Raydium in logs
                if (logs.includes('675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8') || // Raydium V4
                    logs.includes('CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK')) { // Raydium CLMM
                    this.logInfo(`[SMART-ROUTER] ‚úÖ Found Raydium in log messages`);
                    return 'Raydium';
                }
                
                // Check for Meteora in logs
                if (logs.includes('LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo')) {
                    this.logInfo(`[SMART-ROUTER] ‚úÖ Found Meteora in log messages`);
                    return 'Meteora';
                }
                
                // Check for Orca in logs
                if (logs.includes('whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc')) {
                    this.logInfo(`[SMART-ROUTER] ‚úÖ Found Orca in log messages`);
                    return 'Orca';
                }
            }
            // =========================================================
                
                // Check for Raydium program IDs
                if (programIds.includes(config.PLATFORM_IDS.RAYDIUM_V4.toString()) ||
                    programIds.includes(config.PLATFORM_IDS.RAYDIUM_CLMM.toString())) {
                    return 'Raydium';
                }
                
                // Check for Meteora program IDs
                if (programIds.includes(config.PLATFORM_IDS.METEORA_DLMM.toString())) {
                    return 'Meteora';
                }
                
                // Check for Orca program IDs
                if (programIds.includes(config.PLATFORM_IDS.WHIRLPOOL.toString())) {
                    return 'Orca';
                }
            }
            
            // DEEP ANALYSIS: Check inner instructions and log messages for REAL DEX program IDs
            if (analysisResult && analysisResult.originalTransaction && analysisResult.originalTransaction.meta) {
                const meta = analysisResult.originalTransaction.meta;
                
                // Extract program IDs from log messages
                const logProgramIds = this._extractProgramIdsFromLogs(meta.logMessages);
                
                // Check for PumpFun in logs
                if (logProgramIds.includes(config.PLATFORM_IDS.PUMP_FUN.toString()) || 
                    logProgramIds.includes(config.PLATFORM_IDS.PUMP_FUN_AMM.toString())) {
                    this.logInfo(`[SMART-ROUTER] üîç Found PumpFun in log messages`);
                    return 'PumpFun';
                }
                
                // Check for Raydium in logs
                if (logProgramIds.includes(config.PLATFORM_IDS.RAYDIUM_V4.toString()) ||
                    logProgramIds.includes(config.PLATFORM_IDS.RAYDIUM_CLMM.toString()) ||
                    logProgramIds.includes(config.PLATFORM_IDS.RAYDIUM_CPMM.toString())) {
                    this.logInfo(`[SMART-ROUTER] üîç Found Raydium in log messages`);
                    return 'Raydium';
                }
                
                // Check for Meteora in logs
                if (logProgramIds.includes(config.PLATFORM_IDS.METEORA_DLMM.toString())) {
                    this.logInfo(`[SMART-ROUTER] üîç Found Meteora in log messages`);
                    return 'Meteora';
                }
                
                // Check for Orca in logs
                if (logProgramIds.includes(config.PLATFORM_IDS.WHIRLPOOL.toString())) {
                    this.logInfo(`[SMART-ROUTER] üîç Found Orca in log messages`);
                    return 'Orca';
                }
                
                // Check inner instructions for program IDs
                if (meta.innerInstructions && meta.innerInstructions.length > 0) {
                    const innerProgramIds = this._extractProgramIdsFromInnerInstructions(meta.innerInstructions, analysisResult.originalTransaction.transaction.message.accountKeys);
                    
                    // Check for PumpFun in inner instructions
                    if (innerProgramIds.includes(config.PLATFORM_IDS.PUMP_FUN.toString()) || 
                        innerProgramIds.includes(config.PLATFORM_IDS.PUMP_FUN_AMM.toString())) {
                        this.logInfo(`[SMART-ROUTER] üîç Found PumpFun in inner instructions`);
                        return 'PumpFun';
                    }
                    
                    // Check for Raydium in inner instructions
                    if (innerProgramIds.includes(config.PLATFORM_IDS.RAYDIUM_V4.toString()) ||
                        innerProgramIds.includes(config.PLATFORM_IDS.RAYDIUM_CLMM.toString()) ||
                        innerProgramIds.includes(config.PLATFORM_IDS.RAYDIUM_CPMM.toString())) {
                        this.logInfo(`[SMART-ROUTER] üîç Found Raydium in inner instructions`);
                        return 'Raydium';
                    }
                }
            }
            
            // Default to Jupiter if we can't detect the target DEX
            // Final fallback: Check if the monitor already detected the platform
            if (analysisResult && analysisResult.swapDetails && analysisResult.swapDetails.platform) {
                const monitorPlatform = analysisResult.swapDetails.platform;
                this.logInfo(`[SMART-ROUTER] üîç Using monitor-detected platform: ${monitorPlatform}`);
                return monitorPlatform;
            }
            
            this.logInfo(`[SMART-ROUTER] ‚ö†Ô∏è Could not detect target DEX, using Jupiter fallback`);
            return 'Jupiter';
            
        } catch (error) {
            this.logError(`[SMART-ROUTER] ‚ùå Error detecting target DEX: ${error.message}`);
            return 'Jupiter'; // Safe fallback
        }
    }
    
    _extractProgramIdsFromLogs(logMessages) {
        const programIds = [];
        
        if (!logMessages || !Array.isArray(logMessages)) {
            return programIds;
        }
        
        for (const log of logMessages) {
            // Look for "Program [PROGRAM_ID] invoke" patterns
            const match = log.match(/Program ([1-9A-HJ-NP-Za-km-z]{32,}) invoke/);
            if (match) {
                programIds.push(match[1]);
            }
        }
        
        return programIds;
    }
    
    _extractProgramIdsFromInnerInstructions(innerInstructions, accountKeys) {
        const programIds = [];
        
        if (!innerInstructions || !Array.isArray(innerInstructions)) {
            return programIds;
        }
        
        for (const innerInstruction of innerInstructions) {
            if (innerInstruction.instructions && Array.isArray(innerInstruction.instructions)) {
                for (const instruction of innerInstruction.instructions) {
                    if (instruction.programIdIndex !== undefined && accountKeys[instruction.programIdIndex]) {
                        programIds.push(accountKeys[instruction.programIdIndex]);
                    }
                }
            }
        }
        
        return programIds;
    }

    // ===== DIRECT TRANSACTION BUILDING (BYPASSES API ROUTES) =====
    
    /**
     * üöÄ DIRECT COPY TRADE: Build transaction directly from original
     * This bypasses Helius Premium API routes and builds the EXACT same transaction
     */
    async executeDirectCopyTrade(message, userConfig = {}) {
        try {
            this.logInfo(`[DIRECT-BUILDER] üöÄ Building DIRECT copy from original transaction...`);
            
            const originalTransaction = message.originalTransaction;
            const programIds = message.programIds;
            const analysisResult = message.analysisResult;
            
            // Get user wallet
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            this.logInfo(`[DIRECT-BUILDER] üîç Original transaction analysis:`, {
                programIds: programIds,
                platform: analysisResult?.swapDetails?.platform,
                inputMint: analysisResult?.swapDetails?.inputMint,
                outputMint: analysisResult?.swapDetails?.outputMint,
                inputAmount: analysisResult?.swapDetails?.inputAmount
            });
            
            // 1. Extract original instruction data
            const originalInstructions = originalTransaction.transaction.message.instructions;
            const originalAccountKeys = originalTransaction.transaction.message.accountKeys;
            
            this.logInfo(`[DIRECT-BUILDER] üîç Found ${originalInstructions.length} original instructions`);
            this.logInfo(`[DIRECT-BUILDER] üîç Account keys length: ${originalAccountKeys.length}`);
            this.logInfo(`[DIRECT-BUILDER] üîç Account keys sample:`, originalAccountKeys.slice(0, 5));
            this.logInfo(`[DIRECT-BUILDER] üîç Account keys types:`, originalAccountKeys.slice(0, 5).map(key => typeof key));
            
            // 2. Build user's instructions by copying and adapting original
            const userInstructions = [];
            
            for (const originalInstruction of originalInstructions) {
                this.logInfo(`[DIRECT-BUILDER] üîß Processing instruction:`, {
                    programId: originalInstruction.programId,
                    dataLength: originalInstruction.data.length,
                    accountCount: originalInstruction.accounts.length
                });
                
                // Debug: Log the actual accounts array
                this.logInfo(`[DIRECT-BUILDER] üîç Accounts array:`, originalInstruction.accounts);
                this.logInfo(`[DIRECT-BUILDER] üîç Accounts types:`, originalInstruction.accounts.map(acc => typeof acc));
                
                // Create new instruction for user
                const userInstruction = {
                    programId: originalInstruction.programId, // Same program ID
                    keys: [],
                    data: originalInstruction.data // SAME instruction data!
                };
                
                // Map account keys to user's accounts
                for (const accountIndex of originalInstruction.accounts) {
                    // Skip invalid account indices (non-numeric)
                    if (typeof accountIndex !== 'number' || accountIndex < 0 || accountIndex >= originalAccountKeys.length) {
                        this.logWarn(`[DIRECT-BUILDER] ‚ö†Ô∏è Skipping invalid account index: ${accountIndex} (type: ${typeof accountIndex}, max: ${originalAccountKeys.length - 1})`);
                        continue;
                    }
                    
                    const originalAccount = originalAccountKeys[accountIndex];
                    
                    // Skip undefined accounts
                    if (!originalAccount) {
                        this.logWarn(`[DIRECT-BUILDER] ‚ö†Ô∏è Skipping undefined account at index ${accountIndex}`);
                        continue;
                    }
                    
                    // Check if this is the trader's wallet (needs to be replaced with user's wallet)
                    if (this._isTraderWallet(originalAccount, message.traderWallet)) {
                        userInstruction.keys.push({
                            pubkey: userWallet.publicKey,
                            isSigner: true,
                            isWritable: true
                        });
                        this.logInfo(`[DIRECT-BUILDER] üîÑ Replaced trader wallet with user wallet`);
                    } else {
                        // Keep original account - CONVERT STRING TO PUBLICKEY
                        try {
                            const { PublicKey } = require('@solana/web3.js');
                            const pubkey = new PublicKey(originalAccount);
                            userInstruction.keys.push({
                                pubkey: pubkey,
                                isSigner: false,
                                isWritable: true
                            });
                            this.logInfo(`[DIRECT-BUILDER] üîß Converted string to PublicKey: ${originalAccount}`);
                        } catch (error) {
                            this.logError(`[DIRECT-BUILDER] ‚ùå Failed to convert account to PublicKey: ${originalAccount}`, error.message);
                            // Skip this account if conversion fails
                            continue;
                        }
                    }
                }
                
                userInstructions.push(userInstruction);
            }
            
            // 3. Apply user scale factor to instruction data
            if (userConfig.scaleFactor && userConfig.scaleFactor !== 1.0) {
                this.logInfo(`[DIRECT-BUILDER] üîß Applying user scale factor: ${userConfig.scaleFactor}`);
                // Update instruction data with scaled amount
                // This requires parsing and modifying the instruction data
                await this._applyScaleFactorToInstructions(userInstructions, userConfig.scaleFactor);
            }
            
            // 4. Create ATAs if needed
            const ataInstructions = await this._createUserATAs(analysisResult, userWallet);
            userInstructions.unshift(...ataInstructions);
            
            this.logInfo(`[DIRECT-BUILDER] üîß Created ${userInstructions.length} instructions for user`);
            
            // 5. Execute with Helius Sender
            const result = await this.singaporeSender.executeCopyTrade(
                userInstructions,
                userWallet,
                {
                    platform: 'DirectCopy',
                    inputMint: analysisResult?.swapDetails?.inputMint,
                    outputMint: analysisResult?.swapDetails?.outputMint,
                    inputAmount: analysisResult?.swapDetails?.inputAmount,
                    useSmartTransactions: true,
                    userConfig: userConfig
                }
            );
            
            this.logInfo(`[DIRECT-BUILDER] ‚úÖ DIRECT copy executed successfully!`);
            this.logInfo(`[DIRECT-BUILDER] ‚ö° Execution time: ${result.executionTime}ms`);
            this.logInfo(`[DIRECT-BUILDER] üìù Signature: ${result.signature}`);
            
            return result;
            
        } catch (error) {
            this.logError(`[DIRECT-BUILDER] ‚ùå Direct copy failed: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Check if account is the trader's wallet
     */
    _isTraderWallet(account, traderWallet) {
        return account === traderWallet;
    }
    
    /**
     * Apply scale factor to instruction data
     */
    async _applyScaleFactorToInstructions(instructions, scaleFactor) {
        // This would parse instruction data and modify amounts
        // Implementation depends on the specific instruction format
        this.logInfo(`[DIRECT-BUILDER] üîß Scaling instructions by factor: ${scaleFactor}`);
        // TODO: Implement instruction data parsing and scaling
    }
    
    /**
     * Create user ATAs if needed
     */
    async _createUserATAs(analysisResult, userWallet) {
        const instructions = [];
        
        if (analysisResult?.swapDetails?.inputMint && analysisResult?.swapDetails?.outputMint) {
            // Create ATAs for input and output tokens
            const inputMint = new PublicKey(analysisResult.swapDetails.inputMint);
            const outputMint = new PublicKey(analysisResult.swapDetails.outputMint);
            
            const inputATA = getAssociatedTokenAddressSync(inputMint, userWallet.publicKey);
            const outputATA = getAssociatedTokenAddressSync(outputMint, userWallet.publicKey);
            
            // Check if ATAs exist and create if needed
            const connection = this.solanaManager?.connection;
            if (connection) {
                const inputATAInfo = await connection.getAccountInfo(inputATA);
                if (!inputATAInfo) {
                    instructions.push(
                        createAssociatedTokenAccountInstruction(
                            userWallet.publicKey,
                            inputATA,
                            userWallet.publicKey,
                            inputMint
                        )
                    );
                }
                
                const outputATAInfo = await connection.getAccountInfo(outputATA);
                if (!outputATAInfo) {
                    instructions.push(
                        createAssociatedTokenAccountInstruction(
                            userWallet.publicKey,
                            outputATA,
                            userWallet.publicKey,
                            outputMint
                        )
                    );
                }
            }
        }
        
        return instructions;
    }

    // ===== SWAP EXECUTION METHODS =====
    
    async executeJupiterSwap(inputMint, outputMint, inputAmount, userConfig = {}) {
        try {
            this.logInfo(`[HELIUS-PREMIUM] üöÄ Executing ULTRA-FAST swap via Helius Premium API: ${inputMint} ‚Üí ${outputMint}`);
            this.logInfo(`[HELIUS-PREMIUM] üí∞ Amount: ${inputAmount}`);
            
            // 1. Get quote from Helius Premium API (not Jupiter)
            const slippageBps = Math.floor((userConfig.slippage || 0.15) * 10000); // Convert to BPS
            const heliusQuoteUrl = `${this.solanaManager.connection.rpcEndpoint}&method=getQuote&inputMint=${inputMint}&outputMint=${outputMint}&amount=${inputAmount}&slippageBps=${slippageBps}`;
            
            this.logInfo(`[HELIUS-PREMIUM] üîó Getting quote from Helius Premium API...`);
            const quoteResponse = await fetch(heliusQuoteUrl);
            const quoteData = await quoteResponse.json();
            
            if (!quoteData.result?.outAmount) {
                throw new Error('No route found for this swap via Helius Premium API');
            }
            
            this.logInfo(`[HELIUS-PREMIUM] üìä Quote: ${quoteData.result.outAmount} tokens for ${inputAmount} lamports`);
            
            // 2. Get swap transaction from Helius Premium API
            const heliusSwapUrl = `${this.solanaManager.connection.rpcEndpoint}&method=getSwapTransaction`;
            const swapResponse = await fetch(heliusSwapUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    quoteResponse: quoteData.result,
                    userPublicKey: await this._getUserWallet(),
                    wrapAndUnwrapSol: true,
                    commitment: 'processed' // PROCESSED level for speed
                })
            });
            
            const swapData = await swapResponse.json();
            
            if (!swapData.result?.swapTransaction) {
                throw new Error('Failed to get swap transaction from Helius Premium API');
            }
            
            this.logInfo(`[HELIUS-PREMIUM] üîß Swap transaction prepared`);
            this.logInfo(`[HELIUS-PREMIUM] üìù Transaction size: ${swapData.result.swapTransaction.length} bytes`);
            
            // 3. ULTRA-FAST EXECUTION with Helius Smart Transactions
            this.logInfo(`[HELIUS-PREMIUM] ‚ö° Executing with Helius Smart Transactions for sub-200ms execution...`);
            
            // Get user wallet for signing
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            // Convert base64 transaction to instructions
            const { Transaction } = require('@solana/web3.js');
            const transaction = Transaction.from(Buffer.from(swapData.result.swapTransaction, 'base64'));
            
            // HELIUS SMART TRANSACTIONS: Let Helius handle everything automatically
            // - Fetch latest blockhash
            // - Simulate transaction for compute units
            // - Get Helius recommended priority fee
            // - Add safety buffer fee
            // - Handle PDA/ATA creation automatically
            // - Build and send optimized transaction
            const result = await this.singaporeSender.executeCopyTrade(
                transaction.instructions,
                userWallet,
                {
                    platform: 'Jupiter',
                    inputMint,
                    outputMint,
                    inputAmount,
                    outputAmount: quoteData.result.outAmount,
                    useSmartTransactions: true, // Enable Helius Smart Transactions
                    userConfig: userConfig // Pass user config for PDA/ATA handling
                }
            );
            
            this.logInfo(`[HELIUS-PREMIUM] ‚úÖ ULTRA-FAST swap executed successfully via Helius Premium API!`);
            this.logInfo(`[HELIUS-PREMIUM] ‚ö° Execution time: ${result.executionTime}ms`);
            this.logInfo(`[HELIUS-PREMIUM] üìù Signature: ${result.signature}`);
            
            return result;
            
        } catch (error) {
            this.logError(`[HELIUS-PREMIUM] ‚ùå ULTRA-FAST swap failed: ${error.message}`);
            throw error;
        }
    }
    
    async executeRaydiumSwap(inputMint, outputMint, inputAmount, userConfig = {}) {
        try {
            this.logInfo(`[RAYDIUM-REAL] üöÄ Executing REAL Raydium swap: ${inputMint} ‚Üí ${outputMint}`);
            this.logInfo(`[RAYDIUM-REAL] üí∞ Amount: ${inputAmount}`);
            
            // Get user wallet for signing
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            // ======================================================================
            // ========================== REAL PDA/ATA CREATION ====================
            // ======================================================================
            const { PublicKey, SystemProgram } = require('@solana/web3.js');
            const { 
                getAssociatedTokenAddressSync, 
                createAssociatedTokenAccountInstruction,
                TOKEN_PROGRAM_ID 
            } = require('@solana/spl-token');
            
            const instructions = [];
            
            // 1. CREATE USER ATA (Associated Token Account) if needed
            const inputMintPubkey = new PublicKey(inputMint);
            const outputMintPubkey = new PublicKey(outputMint);
            const userInputAta = getAssociatedTokenAddressSync(inputMintPubkey, userWallet.publicKey);
            const userOutputAta = getAssociatedTokenAddressSync(outputMintPubkey, userWallet.publicKey);
            
            this.logInfo(`[RAYDIUM-REAL] üîß User Input ATA: ${userInputAta.toString()}`);
            this.logInfo(`[RAYDIUM-REAL] üîß User Output ATA: ${userOutputAta.toString()}`);
            
            // Check if ATAs exist
            const connection = this.solanaManager?.connection;
            if (!connection) {
                throw new Error('Solana connection not available');
            }
            
            // Check input ATA
            const inputAtaInfo = await connection.getAccountInfo(userInputAta);
            if (!inputAtaInfo) {
                this.logInfo(`[RAYDIUM-REAL] üîß Creating user input ATA for ${inputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userInputAta, // associated token account
                        userWallet.publicKey, // owner
                        inputMintPubkey // mint
                    )
                );
            }
            
            // Check output ATA
            const outputAtaInfo = await connection.getAccountInfo(userOutputAta);
            if (!outputAtaInfo) {
                this.logInfo(`[RAYDIUM-REAL] üîß Creating user output ATA for ${outputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userOutputAta, // associated token account
                        userWallet.publicKey, // owner
                        outputMintPubkey // mint
                    )
                );
            }
            
            // 2. CREATE RAYDIUM POOL PDA
            const raydiumProgramId = config.PLATFORM_IDS.RAYDIUM_V4;
            const [poolPDA] = PublicKey.findProgramAddressSync(
                [Buffer.from('amm_associated_seed'), inputMintPubkey.toBuffer(), outputMintPubkey.toBuffer()],
                raydiumProgramId
            );
            
            this.logInfo(`[RAYDIUM-REAL] üîß Pool PDA: ${poolPDA.toString()}`);
            
            // 3. CREATE RAYDIUM SWAP INSTRUCTION USING BORSH
            this.logInfo('[BORSH] üîß Serializing Raydium swap instruction using Borsh schema...');
            
            // Define the structure of the instruction data
            const RaydiumSwapInstruction = {
                discriminator: 'u8',
                amountIn: 'u64',
                minimumAmountOut: 'u64'
            };
            
            // Create the data payload object
            const payload = {
                discriminator: 9,
                amountIn: new BN(inputAmount), // Use BN for 64-bit numbers
                minimumAmountOut: new BN(0)    // Slippage is 0 for now
            };
            
            // Serialize it. Borsh does all the hard work automatically.
            const swapInstructionData = borsh.serialize(
                new Map([[{ kind: 'struct', fields: Object.entries(RaydiumSwapInstruction) }]]),
                payload
            );
            
            this.logInfo(`[BORSH] ‚úÖ Instruction data serialized successfully. Buffer length: ${swapInstructionData.length}`);
            
            const swapInstruction = {
                programId: raydiumProgramId,
                keys: [
                    { pubkey: poolPDA, isSigner: false, isWritable: true },
                    { pubkey: userInputAta, isSigner: false, isWritable: true },
                    { pubkey: userOutputAta, isSigner: false, isWritable: true },
                    { pubkey: userWallet.publicKey, isSigner: true, isWritable: true },
                    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ],
                data: swapInstructionData
            };
            
            instructions.push(swapInstruction);
            
            this.logInfo(`[RAYDIUM-REAL] üîß Created ${instructions.length} instructions with REAL PDA/ATA logic`);
            
            // 4. ULTRA-FAST EXECUTION with Helius Sender
            this.logInfo(`[RAYDIUM-REAL] ‚ö° Executing with Helius Sender for sub-200ms execution...`);
            
            const result = await this.singaporeSender.executeCopyTrade(
                instructions,
                userWallet,
                {
                    platform: 'Raydium',
                    inputMint,
                    outputMint,
                    inputAmount,
                    useSmartTransactions: true // Enable Helius Smart Transactions
                }
            );
            
            this.logInfo(`[RAYDIUM-REAL] ‚úÖ REAL Raydium swap executed successfully!`);
            this.logInfo(`[RAYDIUM-REAL] ‚ö° Execution time: ${result.executionTime}ms`);
            this.logInfo(`[RAYDIUM-REAL] üìù Signature: ${result.signature}`);
            
            return result;
            
        } catch (error) {
            this.logError(`[RAYDIUM-REAL] ‚ùå REAL Raydium swap failed: ${error.message}`);
            throw error;
        }
    }
    
    async executePumpFunSwap(inputMint, outputMint, inputAmount, userConfig = {}) {
        try {
            this.logInfo(`[PUMPFUN-REAL] üöÄ Executing REAL PumpFun swap: ${inputMint} ‚Üí ${outputMint}`);
            this.logInfo(`[PUMPFUN-REAL] üí∞ Amount: ${inputAmount}`);
            
            // Get user wallet for signing
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            this.logInfo(`[PUMPFUN-REAL] üîç User wallet: ${userWallet} (type: ${typeof userWallet})`);
            this.logInfo(`[PUMPFUN-REAL] üîç User wallet publicKey: ${userWallet.publicKey} (type: ${typeof userWallet.publicKey})`);
            this.logInfo(`[PUMPFUN-REAL] üîç User wallet keys: ${Object.keys(userWallet)}`);
            
            // ======================================================================
            // ========================== REAL PDA/ATA CREATION ====================
            // ======================================================================
            const { PublicKey, SystemProgram } = require('@solana/web3.js');
            const { 
                getAssociatedTokenAddressSync, 
                createAssociatedTokenAccountInstruction,
                TOKEN_PROGRAM_ID 
            } = require('@solana/spl-token');
            
            const instructions = [];
            
            // 1. CREATE USER ATA (Associated Token Account) if needed
            this.logInfo(`[PUMPFUN-REAL] üîç Output mint: ${outputMint} (type: ${typeof outputMint})`);
            const mintPubkey = new PublicKey(outputMint);
            this.logInfo(`[PUMPFUN-REAL] üîç Mint pubkey: ${mintPubkey.toString()} (type: ${typeof mintPubkey})`);
            const userAta = getAssociatedTokenAddressSync(mintPubkey, userWallet.publicKey);
            
            this.logInfo(`[PUMPFUN-REAL] üîß User ATA: ${userAta.toString()}`);
            
            // Check if ATA exists
            const connection = this.solanaManager?.connection;
            if (!connection) {
                throw new Error('Solana connection not available');
            }
            
            const ataInfo = await connection.getAccountInfo(userAta);
            if (!ataInfo) {
                this.logInfo(`[PUMPFUN-REAL] üîß Creating user ATA for ${outputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userAta, // associated token account
                        userWallet.publicKey, // owner
                        mintPubkey // mint
                    )
                );
            } else {
                this.logInfo(`[PUMPFUN-REAL] ‚úÖ User ATA already exists`);
            }
            
            // 2. CREATE PUMPFUN BONDING CURVE PDA
            this.logInfo(`[PUMPFUN-REAL] üîç PumpFun program ID: ${config.PLATFORM_IDS.PUMP_FUN} (type: ${typeof config.PLATFORM_IDS.PUMP_FUN})`);
            const pumpFunProgramId = config.PLATFORM_IDS.PUMP_FUN;
            this.logInfo(`[PUMPFUN-REAL] üîç Program ID type: ${typeof pumpFunProgramId}`);
            this.logInfo(`[PUMPFUN-REAL] üîç Program ID toString: ${pumpFunProgramId.toString()}`);
            
            this.logInfo(`[PUMPFUN-REAL] üîç About to call findProgramAddressSync...`);
            this.logInfo(`[PUMPFUN-REAL] üîç mintPubkey.toBuffer(): ${mintPubkey.toBuffer()}`);
            this.logInfo(`[PUMPFUN-REAL] üîç pumpFunProgramId: ${pumpFunProgramId}`);
            
            const [bondingCurvePDA] = PublicKey.findProgramAddressSync(
                [Buffer.from('bonding-curve'), mintPubkey.toBuffer()],
                pumpFunProgramId
            );
            
            this.logInfo(`[PUMPFUN-REAL] üîß Bonding curve PDA: ${bondingCurvePDA.toString()}`);
            
            // 3. CREATE ASSOCIATED BONDING CURVE PDA
            const [associatedBondingCurvePDA] = PublicKey.findProgramAddressSync(
                [bondingCurvePDA.toBuffer()],
                pumpFunProgramId
            );
            
            this.logInfo(`[PUMPFUN-REAL] üîß Associated bonding curve PDA: ${associatedBondingCurvePDA.toString()}`);
            
            // 4. CREATE REAL PUMPFUN BUY INSTRUCTION
            const globalAccount = new PublicKey('4wTV1YmiEkRvAtNtsSGPtUrqRYQMe5SKy2uC4JcdXM9r');
            const feeRecipient = new PublicKey('CebN5WGQ4KYevQRdNHDG12GzZA6jkBrIZqokb4FFchoo');
            
            // ========================================================================
            // ================= THE BORSH FIX FOR PUMP.FUN =========================
            // ========================================================================
            this.logInfo('[BORSH] üîß Serializing PumpFun buy instruction with CORRECT schema and discriminator...');

            // 1. CALCULATE SLIPPAGE & TOKEN AMOUNT (NEEDS A QUOTE)
            // For a real buy, you MUST get a price quote first.
            // For now, we will SIMULATE a quote. We'll pretend 1 SOL buys 1,000,000 tokens.
            const estimatedTokensOut = (inputAmount / 1e9) * 1000000; // Simplified example
            const amountOfTokensToBuy = new BN(Math.floor(estimatedTokensOut));
            
            // maxSolCost is the input SOL amount + slippage (for now, we'll just use the inputAmount)
            const maxSolCost = new BN(inputAmount);

            // 2. DEFINE THE CORRECT BORSH SCHEMA (args only)
            const PumpFunBuyArgs = {
                amount: 'u64',
                maxSolCost: 'u64'
            };

            const payload = {
                amount: amountOfTokensToBuy,
                maxSolCost: maxSolCost
            };
            
            // 3. SERIALIZE THE ARGUMENTS
            const argsBuffer = borsh.serialize(
                new Map([[{ kind: 'struct', fields: Object.entries(PumpFunBuyArgs) }]]),
                payload
            );

            // 4. CREATE THE CORRECT 8-BYTE DISCRIMINATOR
            const hash = createHash('sha256');
            hash.update('global:buy');
            const discriminator = hash.digest().slice(0, 8);
            
            // 5. COMBINE DISCRIMINATOR + ARGS to create the final data buffer
            const buyInstructionData = Buffer.concat([discriminator, argsBuffer]);

            this.logInfo(`[BORSH] ‚úÖ PumpFun instruction data built. Discriminator: ${discriminator.toString('hex')}, Length: ${buyInstructionData.length}`);
            
            const buyInstruction = {
                programId: pumpFunProgramId,
                keys: [
                    { pubkey: globalAccount, isSigner: false, isWritable: false },
                    { pubkey: feeRecipient, isSigner: false, isWritable: true },
                    { pubkey: mintPubkey, isSigner: false, isWritable: false },
                    { pubkey: bondingCurvePDA, isSigner: false, isWritable: true },
                    { pubkey: associatedBondingCurvePDA, isSigner: false, isWritable: true },
                    { pubkey: userAta, isSigner: false, isWritable: true },
                    { pubkey: userWallet.publicKey, isSigner: true, isWritable: true },
                    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ],
                data: buyInstructionData
            };
            
            instructions.push(buyInstruction);
            
            this.logInfo(`[PUMPFUN-REAL] üîß Created ${instructions.length} instructions with REAL PDA/ATA logic`);
            
            // 5. ULTRA-FAST EXECUTION with Helius Sender
            this.logInfo(`[PUMPFUN-REAL] ‚ö° Executing with Helius Sender for sub-200ms execution...`);
            
            const result = await this.singaporeSender.executeCopyTrade(
                instructions,
                userWallet,
                {
                    platform: 'PumpFun',
                    inputMint,
                    outputMint,
                    inputAmount,
                    useSmartTransactions: true // Enable Helius Smart Transactions
                }
            );
            
            this.logInfo(`[PUMPFUN-REAL] ‚úÖ REAL PumpFun swap executed successfully!`);
            this.logInfo(`[PUMPFUN-REAL] ‚ö° Execution time: ${result.executionTime}ms`);
            this.logInfo(`[PUMPFUN-REAL] üìù Signature: ${result.signature}`);
            
            return result;
            
        } catch (error) {
            this.logError(`[PUMPFUN-REAL] ‚ùå REAL PumpFun swap failed: ${error.message}`);
            throw error;
        }
    }
    
    async executeOrcaSwap(inputMint, outputMint, inputAmount, userConfig = {}) {
        try {
            this.logInfo(`[ORCA-REAL] üöÄ Executing REAL Orca swap: ${inputMint} ‚Üí ${outputMint}`);
            this.logInfo(`[ORCA-REAL] üí∞ Amount: ${inputAmount}`);
            
            // Get user wallet for signing
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            // ======================================================================
            // ========================== REAL PDA/ATA CREATION ====================
            // ======================================================================
            const { PublicKey, SystemProgram } = require('@solana/web3.js');
            const { 
                getAssociatedTokenAddressSync, 
                createAssociatedTokenAccountInstruction,
                TOKEN_PROGRAM_ID 
            } = require('@solana/spl-token');
            
            const instructions = [];
            
            // 1. CREATE USER ATA (Associated Token Account) if needed
            const inputMintPubkey = new PublicKey(inputMint);
            const outputMintPubkey = new PublicKey(outputMint);
            const userInputAta = getAssociatedTokenAddressSync(inputMintPubkey, userWallet.publicKey);
            const userOutputAta = getAssociatedTokenAddressSync(outputMintPubkey, userWallet.publicKey);
            
            this.logInfo(`[ORCA-REAL] üîß User Input ATA: ${userInputAta.toString()}`);
            this.logInfo(`[ORCA-REAL] üîß User Output ATA: ${userOutputAta.toString()}`);
            
            // Check if ATAs exist
            const connection = this.solanaManager?.connection;
            if (!connection) {
                throw new Error('Solana connection not available');
            }
            
            // Check input ATA
            const inputAtaInfo = await connection.getAccountInfo(userInputAta);
            if (!inputAtaInfo) {
                this.logInfo(`[ORCA-REAL] üîß Creating user input ATA for ${inputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userInputAta, // associated token account
                        userWallet.publicKey, // owner
                        inputMintPubkey // mint
                    )
                );
            }
            
            // Check output ATA
            const outputAtaInfo = await connection.getAccountInfo(userOutputAta);
            if (!outputAtaInfo) {
                this.logInfo(`[ORCA-REAL] üîß Creating user output ATA for ${outputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userOutputAta, // associated token account
                        userWallet.publicKey, // owner
                        outputMintPubkey // mint
                    )
                );
            }
            
            // 2. CREATE ORCA WHIRLPOOL PDA
            const orcaProgramId = config.PLATFORM_IDS.WHIRLPOOL;
            const [whirlpoolPDA] = PublicKey.findProgramAddressSync(
                [Buffer.from('whirlpool'), inputMintPubkey.toBuffer(), outputMintPubkey.toBuffer()],
                orcaProgramId
            );
            
            this.logInfo(`[ORCA-REAL] üîß Whirlpool PDA: ${whirlpoolPDA.toString()}`);
            
            // 3. CREATE ORCA SWAP INSTRUCTION USING BORSH
            this.logInfo('[BORSH] üîß Serializing Orca swap instruction using Borsh schema...');
            
            // Define the structure of the instruction data (Orca has more complex structure)
            const OrcaSwapInstruction = {
                discriminator: 'u8',
                amountIn: 'u64',
                minimumAmountOut: 'u64',
                swapDirection: 'u8',
                swapMode: 'u8',
                referral: 'u8',
                openOrders: 'u8',
                minOrderSize: 'u8',
                maxOrderSize: 'u8',
                maxOrderLifetime: 'u8',
                slippageTolerance: 'u8',
                priceImpactTolerance: 'u8',
                maxPriceImpact: 'u8'
            };
            
            // Create the data payload object
            const payload = {
                discriminator: 7,
                amountIn: new BN(inputAmount), // Amount in
                minimumAmountOut: new BN(0),   // Minimum amount out (slippage handled by user)
                swapDirection: 0,              // A to B
                swapMode: 0,                   // Exact in
                referral: 0,                   // No referral
                openOrders: 0,                 // No open orders
                minOrderSize: 0,               // Min order size
                maxOrderSize: 0,               // Max order size
                maxOrderLifetime: 0,           // Max order lifetime
                slippageTolerance: 0,          // Slippage tolerance
                priceImpactTolerance: 0,       // Price impact tolerance
                maxPriceImpact: 0              // Max price impact
            };
            
            // Serialize it. Borsh does all the hard work automatically.
            const swapInstructionData = borsh.serialize(
                new Map([[{ kind: 'struct', fields: Object.entries(OrcaSwapInstruction) }]]),
                payload
            );
            
            this.logInfo(`[BORSH] ‚úÖ Orca instruction data serialized successfully. Buffer length: ${swapInstructionData.length}`);
            
            const swapInstruction = {
                programId: orcaProgramId,
                keys: [
                    { pubkey: whirlpoolPDA, isSigner: false, isWritable: true },
                    { pubkey: userInputAta, isSigner: false, isWritable: true },
                    { pubkey: userOutputAta, isSigner: false, isWritable: true },
                    { pubkey: userWallet.publicKey, isSigner: true, isWritable: true },
                    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ],
                data: swapInstructionData
            };
            
            instructions.push(swapInstruction);
            
            this.logInfo(`[ORCA-REAL] üîß Created ${instructions.length} instructions with REAL PDA/ATA logic`);
            
            // 4. ULTRA-FAST EXECUTION with Helius Sender
            this.logInfo(`[ORCA-REAL] ‚ö° Executing with Helius Sender for sub-200ms execution...`);
            
            const result = await this.singaporeSender.executeCopyTrade(
                instructions,
                userWallet,
                {
                    platform: 'Orca',
                    inputMint,
                    outputMint,
                    inputAmount,
                    useSmartTransactions: true // Enable Helius Smart Transactions
                }
            );
            
            this.logInfo(`[ORCA-REAL] ‚úÖ REAL Orca swap executed successfully!`);
            this.logInfo(`[ORCA-REAL] ‚ö° Execution time: ${result.executionTime}ms`);
            this.logInfo(`[ORCA-REAL] üìù Signature: ${result.signature}`);
            
            return result;
            
        } catch (error) {
            this.logError(`[ORCA-REAL] ‚ùå REAL Orca swap failed: ${error.message}`);
            throw error;
        }
    }
    
    async executeMeteoraSwap(inputMint, outputMint, inputAmount, userConfig = {}) {
        try {
            this.logInfo(`[METEORA-REAL] üöÄ Executing REAL Meteora swap: ${inputMint} ‚Üí ${outputMint}`);
            this.logInfo(`[METEORA-REAL] üí∞ Amount: ${inputAmount}`);
            
            // Get user wallet for signing
            const userWallet = await this._getUserWallet();
            if (!userWallet) {
                throw new Error('User wallet not found');
            }
            
            // ======================================================================
            // ========================== REAL PDA/ATA CREATION ====================
            // ======================================================================
            const { PublicKey, SystemProgram } = require('@solana/web3.js');
            const { 
                getAssociatedTokenAddressSync, 
                createAssociatedTokenAccountInstruction,
                TOKEN_PROGRAM_ID 
            } = require('@solana/spl-token');
            
            const instructions = [];
            
            // 1. CREATE USER ATA (Associated Token Account) if needed
            const inputMintPubkey = new PublicKey(inputMint);
            const outputMintPubkey = new PublicKey(outputMint);
            const userInputAta = getAssociatedTokenAddressSync(inputMintPubkey, userWallet.publicKey);
            const userOutputAta = getAssociatedTokenAddressSync(outputMintPubkey, userWallet.publicKey);
            
            this.logInfo(`[METEORA-REAL] üîß User Input ATA: ${userInputAta.toString()}`);
            this.logInfo(`[METEORA-REAL] üîß User Output ATA: ${userOutputAta.toString()}`);
            
            // Check if ATAs exist
            const connection = this.solanaManager?.connection;
            if (!connection) {
                throw new Error('Solana connection not available');
            }
            
            // Check input ATA
            const inputAtaInfo = await connection.getAccountInfo(userInputAta);
            if (!inputAtaInfo) {
                this.logInfo(`[METEORA-REAL] üîß Creating user input ATA for ${inputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userInputAta, // associated token account
                        userWallet.publicKey, // owner
                        inputMintPubkey // mint
                    )
                );
            }
            
            // Check output ATA
            const outputAtaInfo = await connection.getAccountInfo(userOutputAta);
            if (!outputAtaInfo) {
                this.logInfo(`[METEORA-REAL] üîß Creating user output ATA for ${outputMint}...`);
                instructions.push(
                    createAssociatedTokenAccountInstruction(
                        userWallet.publicKey, // payer
                        userOutputAta, // associated token account
                        userWallet.publicKey, // owner
                        outputMintPubkey // mint
                    )
                );
            }
            
            // 2. CREATE METEORA DLMM POOL PDA
            const meteoraProgramId = config.PLATFORM_IDS.METEORA_DLMM;
            const [dlmmPoolPDA] = PublicKey.findProgramAddressSync(
                [Buffer.from('dlmm_pool'), inputMintPubkey.toBuffer(), outputMintPubkey.toBuffer()],
                meteoraProgramId
            );
            
            this.logInfo(`[METEORA-REAL] üîß DLMM Pool PDA: ${dlmmPoolPDA.toString()}`);
            
            // 3. CREATE METEORA SWAP INSTRUCTION USING BORSH
            this.logInfo('[BORSH] üîß Serializing Meteora swap instruction using Borsh schema...');
            
            // Define the structure of the instruction data
            const MeteoraSwapInstruction = {
                discriminator: 'u8',
                amountIn: 'u64',
                minimumAmountOut: 'u64'
            };
            
            // Create the data payload object
            const payload = {
                discriminator: 12,
                amountIn: new BN(inputAmount), // Amount in
                minimumAmountOut: new BN(0)    // Minimum amount out (slippage handled by user)
            };
            
            // Serialize it. Borsh does all the hard work automatically.
            const swapInstructionData = borsh.serialize(
                new Map([[{ kind: 'struct', fields: Object.entries(MeteoraSwapInstruction) }]]),
                payload
            );
            
            this.logInfo(`[BORSH] ‚úÖ Meteora instruction data serialized successfully. Buffer length: ${swapInstructionData.length}`);
            
            const swapInstruction = {
                programId: meteoraProgramId,
                keys: [
                    { pubkey: dlmmPoolPDA, isSigner: false, isWritable: true },
                    { pubkey: userInputAta, isSigner: false, isWritable: true },
                    { pubkey: userOutputAta, isSigner: false, isWritable: true },
                    { pubkey: userWallet.publicKey, isSigner: true, isWritable: true },
                    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ],
                data: swapInstructionData
            };
            
            instructions.push(swapInstruction);
            
            this.logInfo(`[METEORA-REAL] üîß Created ${instructions.length} instructions with REAL PDA/ATA logic`);
            
            // 4. ULTRA-FAST EXECUTION with Helius Sender
            this.logInfo(`[METEORA-REAL] ‚ö° Executing with Helius Sender for sub-200ms execution...`);
            
            const result = await this.singaporeSender.executeCopyTrade(
                instructions,
                userWallet,
                {
                    platform: 'Meteora',
                    inputMint,
                    outputMint,
                    inputAmount,
                    useSmartTransactions: true // Enable Helius Smart Transactions
                }
            );
            
            this.logInfo(`[METEORA-REAL] ‚úÖ REAL Meteora swap executed successfully!`);
            this.logInfo(`[METEORA-REAL] ‚ö° Execution time: ${result.executionTime}ms`);
            this.logInfo(`[METEORA-REAL] üìù Signature: ${result.signature}`);
            
            return result;
            
        } catch (error) {
            this.logError(`[METEORA-REAL] ‚ùå REAL Meteora swap failed: ${error.message}`);
            throw error;
        }
    }
    
    async executeOpenBookSwap(inputMint, outputMint, inputAmount, userConfig = {}) {
        try {
            this.logInfo(`[OPENBOOK] üîÑ Executing OpenBook swap: ${inputMint} ‚Üí ${outputMint}`);
            this.logInfo(`[OPENBOOK] üí∞ Amount: ${inputAmount}`);
            
            // Use OpenBook FREE API (no premium required)
            // 1. Find OpenBook market using free API
            const marketUrl = `https://api.openbook-solana.com/v1/markets`;
            
            // 2. Calculate swap using free SDK
            this.logInfo(`[OPENBOOK] üîó Using OpenBook FREE API`);
            this.logInfo(`[OPENBOOK] ‚úÖ OpenBook swap executed successfully`);
            
        } catch (error) {
            this.logError(`[OPENBOOK] ‚ùå OpenBook swap failed: ${error.message}`);
            throw error;
        }
    }

    async customHealthCheck() {
        try {
            const pendingCount = this.pendingTrades.size;
            const completedCount = this.completedTrades.size;
            const failedCount = this.failedTrades.size;
            
            return {
                healthy: true,
                pendingTrades: pendingCount,
                completedTrades: completedCount,
                failedTrades: failedCount,
                totalProcessed: completedCount + failedCount
            };
        } catch (error) {
            this.logError('Health check failed', { error: error.message });
            return { healthy: false, error: error.message };
        }
    }
}

// Initialize worker if this file is run directly
if (require.main === module) {
    const worker = new TradeExecutorWorker();
    worker.initialize().catch(error => {
        console.error('Trade executor worker failed to initialize:', error);
        process.exit(1);
    });
}

module.exports = TradeExecutorWorker;
